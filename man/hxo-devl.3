.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "HXO-DEVL" "3" "September 2024" "Library definitions and Demo" ""
.hy
.SH NAME
.PP
hxo-devl \[en] Hybrid Xpl0it module programming demo.
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <hxo-user.h>              //Contains all the definitions needed to get started

size_t _init_hxo(struct HXOParam *hxoParameter)    //HXO predefined entrypoint
{

    //..... INIT CODE HERE .....

    if (/*..ERROR AR INIT..*/)
    {
        return -1;                 //for FETAL error(s)
    }

    if (/*..MINOR ERRORS..*/)
    {
        return /*error_value*/;   //Not a fully successful initialize but isn\[aq]t fetal
                                  //Can be used for debug purposes.
    }    
    return 0;                     //for Successful Initialization :)
}
\f[R]
.fi
.SH DESCRIPTION
.PP
This page demonstrates all necessary things to know to create Hybrid
Xpl0it loader (HXO-loader) compatible (.hxo) modules.
.SH USAGE
.IP \[bu] 2
\[lq]\f[C]_init_hxo\f[R]\[rq] is the \f[B]default
\f[BI]entrypoint\f[B]\f[R], which is called after the hxo module is
loaded.
\f[C]_init_hxo\f[R] has a pointer to a \f[C]struct HXOParam\f[R] as the
argument.
The struct can be \f[I]ignored\f[R] but actually it can have a lot of
use cases.
Such as:
.RS 2
.IP "1." 3
To check if the module is injected into the correct process;
.IP "2." 3
To get it\[cq]s own name and absolute path, which can be used for
loading resources and stuffs, etc.
.PP
The \f[C]struct HXOParam\f[R] Defination
.IP
.nf
\f[C]
struct HXOParam {
    const char *hxo_version; //The hxo version string
    int32_t PID;             //PID of current process
    char *baseName;          //Containing the elf executable name
                        //or, In case of Android: The APP ID

    char *basePath;          //elf executable path
    char *moduleName;        //The hxo module\[aq]s file name
    char *modulePath;        //the hxo module\[aq]s absolute path
};
\f[R]
.fi
.RE
.IP \[bu] 2
\f[C]_init_hxo\f[R] have a return type of \f[C]void *\f[R], which is
used for the module handling, different return values result different
action on the module.
For example:
.RS 2
.IP "1." 3
\f[C]return (void*)  0\f[R] : means initialization successful, module
will stay loaded unless \f[C]AutoUnloadAfterExecution\f[R] is explicitly
enabled.
.IP "2." 3
\f[C]return (void*) -1\f[R] : means \f[B]FETAL ERROR\f[R] at
initialization, module will be unloaded after \f[C]_init_hxo\f[R]
returns.
.IP "3." 3
\f[B]Any other \f[BI]value\f[B]\f[R] : means successful injection but
with warnings.
The returned value will be displayed in hxo log.
This can be used for debugging.
Module stays loaded, same as return value \f[C]0\f[R].
.PP
* As \f[C]size_t\f[R] is same as \f[C]void *\f[R], using size_t as the
return type can be helpful.
.RE
.IP \[bu] 2
\f[B]\f[BI]WARNING\f[B]\f[R]: Here are a few things to keep in mind if
you want to avoid \f[B]seg-faults\f[R]:
.RS 2
.IP "1." 3
If a continuous loop_ processing in needed for a specific module, start
a thread using \f[C]hxo_createthread\f[R], \f[B]do not\f[R] create an
infinite loop under the \f[C]_init_hxo\f[R] function, otherwise,
HXO-loader will be frozen and other hxo modules will not get a chance of
getting loaded.
Always try to run the nessesary checks, initialization code and return a
proper value without any \f[C]sleep\f[R] or delay.
.IP "2." 3
In case of \f[B]fetal error\f[R] \f[I](return value -1)\f[R], it must be
made sure there is \f[B]\f[BI]no thread running\f[B]\f[R] in that
module.
If a thread runs in the module while \f[C]_init_hxo\f[R] returns
\f[C]-1\f[R], it will cause a \f[I]segmentation fault\f[R].
.IP "3." 3
If \f[C]AutoUnloadAfterExecution\f[R] is turned ON in \f[C]HXO.ini\f[R]
config, all the modules in that case have to follow one simple rule:
\f[I]\[lq]Everything will be done in the init function, \f[BI]No running
thread\f[I] after hxo_init returns\[rq]\f[R].
.IP "4." 3
The \f[C]sleep\f[R] timer in \f[C]HXO.ini\f[R] counts a timer for the
hxo files to be loaded.
By default, HXO.ini has \f[C]sleep = 0\f[R] but it may cause issues
related to \f[B]\f[BI]too early injection\f[B]\f[R].
It\[cq]s advised to modify it accordingly to give the process some time
to let it\[cq]s job done, before the injection proceeds.
For example, use a \f[C]sleep = 10\f[R] as a 10 second delay before the
injection.
.RE
.SH DEMO SNIPPET
.IP \[bu] 2
For C:
.IP
.nf
\f[C]
#include <hxo-user.h>              //For hxo API definitions
#include <stdio.h>

void ThreadFunction(void);                         //The thread loop to be ran in parallel
size_t _init_hxo(struct HXOParam *hxoParameter)  //HXO entrypoint
{
    //Check for the hxo version
    if (hxo_cmpversion(hxoParameter->hxo_version, \[dq]1.2.0\[dq]) == -1) {
        fprintf(stderr, \[dq]ERROR: HXO-loader version 1.2.0+ needed!\[rs]n\[dq]); 
        return -1;
    }

    //Check if it\[aq]s the correct process or not
    if(strcmp(hxoParameter->baseName, \[dq]game.elf\[dq]) != 0) {
        fprintf(stderr, \[dq]ERROR: Not the right program.\[rs]n\[dq]); 
        return -1;
    }

    //Start a thread (if needed)
    if(hxo_createthread((HXO_THREAD_FUNCTION) ThreadFunction, NULL) != 0) {
        fprintf(stderr, \[dq]ERROR: Can\[aq]t create thread.\[rs]n\[dq]); 
        return -1;
    }

    //.....MORE INIT CODE.....

    return 0;         //Successful Initialization :)
}
\f[R]
.fi
.IP \[bu] 2
For C++:
.IP
.nf
\f[C]
#include <iostream>
//Cpp function declarations...
void CppThreadFunction(void);                         //The C++ coded thread loop to be ran in parallel

extern \[dq]C\[dq] {
#include <hxo-user.h>                            //For hxo API definitions
size_t _init_hxo(struct HXOParam *hxoParameter)  //HXO entrypoint
{
    //Check for the hxo version
    if (hxo_cmpversion(hxoParameter->hxo_version, \[dq]1.2.0\[dq]) == -1) {
        fprintf(stderr, \[dq]ERROR: HXO-loader version 1.2.0+ needed!\[rs]n\[dq]); 
        return -1;
    }

    //Check if it\[aq]s the correct process or not
    if(strcmp(hxoParameter->baseName, \[dq]game.elf\[dq]) != 0) {
        fprintf(stderr, \[dq]ERROR: Not the right program.\[rs]n\[dq]); 
        return -1;
    }

    //Start a thread (if needed)
    if(hxo_createthread((HXO_THREAD_FUNCTION) CppThreadFunction, NULL) != 0) {
        fprintf(stderr, \[dq]ERROR: Can\[aq]t create thread.\[rs]n\[dq]); 
        return -1;
    }

    //.....MORE INIT CODE.....

    return 0;         //Successful Initialization :)
}
}

//Rest of the C++ code
\f[R]
.fi
.SH SEE ALSO
.PP
hxo-loader(1) - general guide
.SH AUTHORS
bitwaree <bitware@duck.com>.
